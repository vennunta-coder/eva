<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVA - Seu Assistente de IA</title>
    <!-- Configuração do Tailwind CSS e Font Inter -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Define a fonte Inter para o corpo */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* Estilo para que a área de chat ocupe o espaço restante */
        #chat-history {
            scroll-behavior: smooth;
        }

        /* Esconde a barra de rolagem, mantendo a funcionalidade de rolagem */
        #chat-history::-webkit-scrollbar {
            display: none;
        }
        #chat-history {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Estilo customizado para o textarea para melhor usabilidade */
        #user-input {
            resize: none;
            min-height: 48px;
            max-height: 200px;
            overflow-y: auto;
            transition: height 0.2s;
        }

        /* Estilo para o ícone de envio (SVG) */
        .send-icon {
            fill: currentColor;
        }
    </style>
</head>
<body class="bg-gray-50 flex flex-col h-screen font-sans antialiased">

    <!-- Cabeçalho (Header) Fixo -->
    <header class="bg-white p-4 shadow-md border-b border-gray-100 flex items-center justify-center sticky top-0 z-10">
        <!-- Título EVA com cores personalizadas -->
        <h1 class="text-3xl font-extrabold tracking-wider">
            <span class="text-black">E</span>
            <span class="text-orange-500">V</span>
            <span class="text-black">A</span>
        </h1>
        <span class="ml-3 text-xs font-medium text-gray-500 rounded-full bg-indigo-100 px-3 py-1">beta</span>
    </header>

    <!-- Área de Histórico de Conversa -->
    <main id="chat-history" class="flex-grow overflow-y-auto p-4 md:p-6 lg:p-8 space-y-6">
        <!-- Mensagem de Boas-vindas Inicial da EVA -->
        <div class="flex justify-center">
            <div class="max-w-2xl text-center p-6 bg-white rounded-xl shadow-lg border border-indigo-200">
                <p class="text-xl font-semibold text-indigo-800">Olá! Eu sou EVA, sua assistente de IA.</p>
                <p class="text-gray-600 mt-2">Pergunte o que quiser e eu farei o meu melhor para ajudar.</p>
            </div>
        </div>
        <!-- O histórico de mensagens será inserido aqui -->
    </main>

    <!-- Área de Entrada (Input) e Rodapé (Footer) Fixos -->
    <div class="sticky bottom-0 bg-gray-50 p-4 border-t border-gray-200">
        <div class="max-w-3xl mx-auto flex items-end space-x-3">
            
            <!-- Campo de Texto (Textarea) -->
            <textarea
                id="user-input"
                class="flex-grow w-full py-2 px-4 text-base border-2 border-indigo-300 focus:ring-indigo-500 focus:border-indigo-500 rounded-2xl shadow-inner placeholder-gray-500 transition-all duration-200 ease-in-out"
                placeholder="Pergunte qualquer coisa..."
                rows="1"
                oninput="adjustTextareaHeight(this)"
            ></textarea>
            
            <!-- Botão de Envio (Send Button) -->
            <button
                id="send-button"
                class="flex-shrink-0 w-12 h-12 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
                title="Enviar Mensagem"
            >
                <!-- Ícone de seta para cima (Enviar) -->
                <svg class="send-icon w-6 h-6 transform rotate-90" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
                </svg>
            </button>
        </div>
        
        <!-- Indicador de Carregamento -->
        <div id="loading-indicator" class="mt-2 text-center text-sm font-medium text-indigo-500 opacity-0 transition-opacity duration-300">
            EVA está pensando...
        </div>

        <!-- Rodapé (Footer) Adicionado Aqui -->
        <footer class="mt-3 pt-3 text-center text-xs text-gray-400 border-t border-gray-100 mx-auto max-w-3xl">
            EVA AI Assistant. Pode cometer erros. Considere verificar informações importantes.
        </footer>
    </div>

    <script type="module">
        // Variáveis de Configuração e Constantes
        // **IMPORTANTE**: A chave da API é definida como uma string vazia. O ambiente Canvas fornecerá a chave no runtime.
        const apiKey = ""; 
        const API_MODEL = "gemini-2.5-flash-preview-05-20";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${apiKey}`;
        const MAX_RETRIES = 5;

        // Elementos do DOM
        const chatHistory = document.getElementById('chat-history');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Estado da Aplicação
        let isSending = false;

        // --- Funções de Manipulação da UI ---

        /**
         * Ajusta a altura do textarea para acomodar o conteúdo.
         * @param {HTMLTextAreaElement} element - O elemento textarea.
         */
        window.adjustTextareaHeight = (element) => {
            element.style.height = 'auto';
            element.style.height = element.scrollHeight + 'px';
        };

        /**
         * Adiciona uma mensagem ao histórico de chat.
         * @param {string} content - O conteúdo da mensagem (Markdown é suportado).
         * @param {('user'|'model'|'error')} role - O papel (usuário, modelo ou erro).
         * @param {string} [id] - ID único da mensagem para referência.
         * @returns {HTMLElement} O elemento da mensagem criado.
         */
        function addMessageToHistory(content, role, id = `msg-${crypto.randomUUID()}`) {
            const isUser = role === 'user';
            const isError = role === 'error';
            
            const messageContainer = document.createElement('div');
            messageContainer.id = id;
            messageContainer.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            let bgColor = 'bg-indigo-500 text-white';
            let textColor = 'text-white';
            let icon = '';
            let name = 'EVA';
            let padding = 'p-3';

            if (isUser) {
                bgColor = 'bg-gray-200';
                textColor = 'text-gray-800';
                name = 'Você';
                padding = 'p-3';
            } else if (isError) {
                bgColor = 'bg-red-100 border border-red-400';
                textColor = 'text-red-700';
                name = 'Erro';
                padding = 'p-4';
                content = `**Ocorreu um erro:** ${content}`;
            } else {
                // Mensagem do Modelo
                bgColor = 'bg-white shadow-xl ring-1 ring-indigo-500/10';
                textColor = 'text-gray-800';
                icon = `<div class="font-extrabold text-xl text-indigo-600 mr-2">E</div>`; // Ícone simples 'E' para EVA
            }

            const messageBubble = `
                <div class="max-w-3xl lg:max-w-4xl rounded-2xl ${isUser ? 'rounded-br-sm' : 'rounded-tl-sm'} ${padding} ${bgColor} ${textColor} text-base break-words whitespace-pre-wrap transition-all duration-300 ease-in-out transform hover:scale-[1.005]">
                    ${!isUser && !isError ? icon : ''}
                    <div class="${!isUser && !isError ? 'flex items-start' : ''}">
                        ${!isUser && !isError ? icon : ''}
                        <div class="prose max-w-none ${textColor}">
                            ${marked.parse(content)}
                        </div>
                    </div>
                </div>
            `;

            messageContainer.innerHTML = messageBubble;
            chatHistory.appendChild(messageContainer);
            chatHistory.scrollTop = chatHistory.scrollHeight; // Rola para o final
            return messageContainer;
        }
        
        /**
         * Exibe ou oculta o indicador de carregamento e controla o estado do botão de envio.
         * @param {boolean} isLoading - Se a aplicação está carregando.
         */
        function setLoadingState(isLoading) {
            isSending = isLoading;
            sendButton.disabled = isLoading;
            userInput.disabled = isLoading;
            loadingIndicator.classList.toggle('opacity-0', !isLoading);
        }

        /**
         * Atualiza o conteúdo da última mensagem da EVA (usado para streaming ou atualização).
         * @param {string} id - ID do contêiner da mensagem.
         * @param {string} content - O novo conteúdo em Markdown.
         */
        function updateMessageContent(id, content) {
            const messageElement = document.getElementById(id);
            if (messageElement) {
                const contentDiv = messageElement.querySelector('.prose');
                if (contentDiv) {
                    contentDiv.innerHTML = marked.parse(content);
                }
            }
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // --- Funções de Conexão com a API e Lógica Central ---

        /**
         * Lida com a tentativa de chamada da API com retentativas (Exponential Backoff).
         * @param {object} payload - O payload da API.
         * @param {number} attempt - A tentativa atual (começa em 1).
         * @returns {Promise<object>} A resposta JSON da API.
         */
        async function fetchWithRetry(payload, attempt = 1) {
            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000; // 2s, 4s, 8s, ... + jitter

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response.json();
                } else if (response.status === 429 && attempt < MAX_RETRIES) {
                    console.warn(`Tentativa ${attempt} falhou (status ${response.status}). Tentando novamente em ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(payload, attempt + 1);
                } else {
                    const errorData = await response.json().catch(() => ({ message: 'Erro desconhecido na resposta.' }));
                    throw new Error(`Falha na API após ${attempt} tentativas. Status: ${response.status}. Mensagem: ${errorData.message || 'Sem mensagem de erro.'}`);
                }
            } catch (error) {
                if (attempt < MAX_RETRIES) {
                    console.warn(`Erro na rede (Tentativa ${attempt}). Tentando novamente em ${delay / 1000}s...`, error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(payload, attempt + 1);
                }
                throw new Error(`Falha total ao conectar ou receber resposta da API: ${error.message}`);
            }
        }

        /**
         * Envia a mensagem do usuário para a API do Gemini e exibe a resposta.
         */
        async function handleSendMessage() {
            if (isSending) return;

            const prompt = userInput.value.trim();
            if (!prompt) return;

            // 1. Limpar a entrada e mostrar a mensagem do usuário
            userInput.value = '';
            window.adjustTextareaHeight(userInput); // Ajusta a altura de volta para 1 linha
            
            addMessageToHistory(prompt, 'user');
            
            // 2. Definir o estado de carregamento e preparar a bolha da EVA
            setLoadingState(true);
            const evaMessageId = `msg-${crypto.randomUUID()}`;
            addMessageToHistory('Aguardando resposta...', 'model', evaMessageId);

            // Payload da API
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: {
                    parts: [{ text: "Você é EVA, um assistente de IA prestativo e amigável. Responda em português. Mantenha as respostas concisas e claras." }]
                },
            };

            try {
                // 3. Chamar a API com retentativas
                const result = await fetchWithRetry(payload);

                const candidate = result.candidates?.[0];
                let responseText = "Desculpe, não consegui gerar uma resposta significativa. Tente reformular a sua pergunta.";
                
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    responseText = candidate.content.parts[0].text;
                }
                
                // 4. Atualizar o conteúdo da mensagem da EVA
                updateMessageContent(evaMessageId, responseText);
                
            } catch (error) {
                // 5. Exibir erro
                console.error("Erro no processo de envio:", error);
                // Remove a mensagem de carregamento e exibe um erro
                document.getElementById(evaMessageId)?.remove();
                addMessageToHistory(error.message, 'error');
            } finally {
                // 6. Finalizar o estado de carregamento
                setLoadingState(false);
            }
        }

        // --- Configuração de Event Listeners ---

        /**
         * Configura o evento de clique e a tecla Enter.
         */
        function setupEventListeners() {
            sendButton.addEventListener('click', handleSendMessage);
            
            userInput.addEventListener('keydown', (e) => {
                // Envia a mensagem com Enter, a menos que Shift esteja pressionado (para nova linha)
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Impede a quebra de linha padrão do textarea
                    handleSendMessage();
                }
            });
        }
        
        // Carrega o Marked.js para processar Markdown nas respostas
        function loadMarkdownProcessor(callback) {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.17/marked.min.js';
            script.onload = callback;
            document.head.appendChild(script);
        }

        // Inicia a aplicação após o carregamento do processador de Markdown
        loadMarkdownProcessor(() => {
             // Garante que o processador de Markdown está acessível globalmente
            window.marked = marked;
            setupEventListeners();
        });
    </script>
</body>
</html>
